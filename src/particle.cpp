#include "../include/elastic_collisions.hpp"

/*        
    Constructor to initialize the particle's position, velocity, mass, and radius
*/
Particle::Particle(double x, double y) : position{x, y} {
    velocity = random2D(); // Get a random 2D vector by calling the random2D() function
    
    double speed = random(2.0, 6.0); // Get a random speed by calling the random() function
    
    velocity[0] *= speed; // Multiply the x component of the velocity by the speed for particle's movement
    
    velocity[1] *= speed; // Multiply the y component of the velocity by the speed for particle's movement
    
    mass = random(2.0, 6.0); // Get a random mass by calling the random() function
    
    radius = std::sqrt(mass) * 20; // Get the radius of the particles as related rationally to their mass for obtaining consistent sizes for each particle
}

/*
    Obtain a random double value between min and max
*/
double Particle::random(double min, double max) {
    static std::random_device rd; // Get a seed value for the random number generator
    
    static std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
    
    std::uniform_real_distribution<double> distribution(min, max);  // Get a very precise random value by using a uniform distribution
    
    return distribution(gen); // Return the randomized value generated by the distribution
}

/*
    Obtain a random 2D vector
*/
std::array<double, 2> Particle::random2D() {
    std::array<double, 2> random2D;
    
    double angle = Particle::random(0.0, 2 * M_PI); // Get random angle between 0 to full circle as radians
    
    random2D[0] = std::cos(angle); // Get x component of the vector
    
    random2D[1] = std::sin(angle); // Get y component of the vector
    
    return random2D; // Return the 2D vector
}

/*
    Apply a force to the particle
*/
void Particle::applyForce(const std::array<double, 2>& force) {
    std::array<double, 2> f = force;
    
    f[0] /= mass; // Divide the x component of the force by the mass of the particle for getting the acceleration
    
    f[1] /= mass; // Divide the y component of the force by the mass of the particle for getting the acceleration
    
    acceleration[0] += f[0]; // Add the x component of the force to the x component of the acceleration
    
    acceleration[1] += f[1]; // Add the y component of the force to the y component of the acceleration
}

/*        
    Update the particle's position and velocity based on current acceleration
    Formulas:
    x = x0 + v * dt and where x is the final position, x0 is the initial position, v is the velocity, and dt is the time
    v = u + at and where u is the initial velocity, v is the final velocity, a is the acceleration, t is the time
    For simplification, we can assume dt = 1
*/
void Particle::update() {
    /*
    Usage of the v = u + at:
    */
    velocity[0] += acceleration[0]; // Add the x component of the acceleration to the x component of the velocity
    
    velocity[1] += acceleration[1]; // Add the y component of the acceleration to the y component of the velocity
    
    /*
    Usage of the x = x0 + v:
    */
    position[0] += velocity[0]; // Add the x component of the velocity to the x component of the position
    
    position[1] += velocity[1]; // Add the y component of the velocity to the y component of the position
    
    /*
    Reset the acceleration to zero after updating the position and velocity
    */
    acceleration.fill(0.0); // Reset both components of the acceleration to zero
}

