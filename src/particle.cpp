#include "../include/elastic_collisions.hpp"

/*
    Constructor to initialize the particle's position, velocity, mass, and radius
*/
Particle::Particle(double x, double y) : position{x, y} {
    velocity = random2D();           // Get a random 2D vector by calling the random2D() function
    double speed = random(2.0, 3.0); // Get a random speed by calling the random() function
    velocity[0] *= speed;            // Multiply the x component of the velocity by the speed for particle's movement
    velocity[1] *= speed;            // Multiply the y component of the velocity by the speed for particle's movement
    mass = random(3.0, 6.0);         // Get a random mass by calling the random() function
    radius = std::sqrt(mass) * 20;   // Get the radius of the particles as related rationally to their mass for obtaining consistent sizes for each particle
}

/*
    Obtain a random double value between min and max
*/
double Particle::random(double min, double max) {
    static std::random_device rd;                                  // Get a seed value for the random number generator
    static std::mt19937 gen(rd());                                 // Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<double> distribution(min, max); // Get a very precise random value by using a uniform distribution

    return distribution(gen); // Return the randomized value generated by the distribution
}

/*
    Obtain a random 2D vector
*/
std::array<double, 2> Particle::random2D() {
    std::array<double, 2> random2D;
    double angle = Particle::random(0.0, 2 * M_PI); // Get random angle between 0 to full circle as radians
    random2D[0] = std::cos(angle);                  // Get x component of the vector
    random2D[1] = std::sin(angle);                  // Get y component of the vector

    return random2D; // Return the 2D vector
}

/*
    Update the particle's position and velocity based on current acceleration
    Formulas:
    x = x0 + v * dt and where x is the final position, x0 is the initial position, v is the velocity, and dt is the time
    v = u + at and where u is the initial velocity, v is the final velocity, a is the acceleration, t is the time
    For simplification, we can assume dt = 1
*/
void Particle::update() {
    /*
    Usage of the x = x0 + v:
    */
    position[0] += velocity[0]; // Add the x component of the velocity to the x component of the position
    position[1] += velocity[1]; // Add the y component of the velocity to the y component of the position
}

static std::array<double, 2> setMag(const std::array<double, 2> &vec, double magnitude) {
    double length = std::sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
    if (length == 0)
        return {0, 0}; // Avoid division by zero
    return {(vec[0] / length) * magnitude, (vec[1] / length) * magnitude};
}

void Particle::collide(Particle &other) {

    std::array<double, 2> impactVector = {other.position[0] - position[0], other.position[1] - position[1]};
    double distance = std::hypot(impactVector[0], impactVector[1]);

    // Check if the particles overlap (collision occurs)
    if (distance < radius + other.radius) {
        double beforeTotalKinetic = 0.5 * mass * (velocity[0] * velocity[0] + velocity[1] * velocity[1]) +
                                    0.5 * other.mass * (other.velocity[0] * other.velocity[0] + other.velocity[1] * other.velocity[1]);

        double beforeTotalMomentumX = mass * velocity[0] + other.mass * other.velocity[0];
        double beforeTotalMomentumY = mass * velocity[1] + other.mass * other.velocity[1];
        double beforeTotalMomentum = hypot(beforeTotalMomentumX, beforeTotalMomentumY);

        double overlap = (radius + other.radius - distance);
        std::array<double, 2> direction = {impactVector[0] / distance, impactVector[1] / distance};

        // Push particles apart to correct overlap
        position[0] -= direction[0] * (overlap * 0.5);
        position[1] -= direction[1] * (overlap * 0.5);
        other.position[0] += direction[0] * (overlap * 0.5);
        other.position[1] += direction[1] * (overlap * 0.5);

        // correct the distance after collision
        distance = radius + other.radius; // after collision distance for applying formula
        impactVector = setMag(impactVector, distance);

        /*
        After collision:
        Formula for new velocities after collision:
        v1' = v1 + (2 * m2 / (m1 + m2)) * (((v2 - v1) * (x2 - x1)) / |x2 - x1|^2)) * (x2 - x1)
        v2' = v2 + (2 * m1 / (m1 + m2)) * (((v1 - v2) * (x1 - x2)) / |x1 - x2|^2)) * (x1 - x2)
        where v1 and v2 are the initial velocities of the two particles, v1' and v2' are the final velocities of the two particles, m1 and m2 are the masses of the two particles, and x1 and x2 are the positions of the two particles
        */
        double massSum = mass + other.mass;                                                               // Get the sum of the masses of the two particles for applying the formula of new velocities after collision
        std::array<double, 2> vDiff = {other.velocity[0] - velocity[0], other.velocity[1] - velocity[1]}; // Get the difference between the velocities of the two particles by vector subtraction
        double numerator = vDiff[0] * impactVector[0] + vDiff[1] * impactVector[1];                       // Get the numerator of the formula
        double denominator = massSum * distance * distance;                                               // Get the denominator of the formula

        /*
        Get the change in velocities for the two particles after collision
        */
        std::array<double, 2> deltaVA = {impactVector[0] * (2 * other.mass * numerator / denominator),
                                         impactVector[1] * (2 * other.mass * numerator / denominator)};

        velocity[0] += deltaVA[0]; // Update the x component of the velocity of the current particle
        velocity[1] += deltaVA[1]; // Update the y component of the velocity of the current particle

        std::array<double, 2> deltaVB = {impactVector[0] * (-2 * mass * numerator / denominator),
                                         impactVector[1] * (-2 * mass * numerator / denominator)};

        other.velocity[0] += deltaVB[0]; // Update the x component of the velocity of the other particle
        other.velocity[1] += deltaVB[1]; // Update the y component of the velocity of the other particle

        double afterTotalKinetic = 0.5 * mass * (velocity[0] * velocity[0] + velocity[1] * velocity[1]) +
                                   0.5 * other.mass * (other.velocity[0] * other.velocity[0] + other.velocity[1] * other.velocity[1]);

        double afterTotalMomentumX = mass * velocity[0] + other.mass * other.velocity[0];
        double afterTotalMomentumY = mass * velocity[1] + other.mass * other.velocity[1];
        double afterTotalMomentum = hypot(afterTotalMomentumX, afterTotalMomentumY);

        system("clear");
        std::cout << "Before momentum: " << beforeTotalMomentum << ", " << "After momentum: " << afterTotalMomentum << ", " << "Before kinetic: " << beforeTotalKinetic << ", " << "After kinetic: " << afterTotalKinetic << std::endl;
    }
}

/*
Check if the particle is at the edges of the window and bounce it off the edges
*/
void Particle::edges(double width, double height) {
    if (position[0] > width - radius) { // Check if the particle is at the right edge of the window
        position[0] = width - radius; // Set the x component of the position to the right edge of the window
        velocity[0] *= -1; // Reverse the x component of the velocity for bouncing off the right edge of the window
    } else if (position[0] < radius) { // Check if the particle is at the left edge of the window
        position[0] = radius; // Set the x component of the position to the left edge of the window
        velocity[0] *= -1; // Reverse the x component of the velocity for bouncing off the left edge of the window
    } else if (position[1] > height - radius) { // Check if the particle is at the top edge of the window
        position[1] = height - radius; // Set the y component of the position to the top edge of the window
        velocity[1] *= -1; // Reverse the y component of the velocity for bouncing off the top edge of the window
    } else if (position[1] < radius) { // Check if the particle is at the bottom edge of the window
        position[1] = radius; // Set the y component of the position to the bottom edge of the window
        velocity[1] *= -1; // Reverse the y component of the velocity for bouncing off the bottom edge of the window
    }
}

/*
    Draw the particle on the window
*/
void Particle::draw(sf::RenderWindow &window) {
    sf::CircleShape circle(radius);                                 // Create a circle shape with the radius of the particle
    circle.setFillColor(sf::Color::White);                          // Set the fill color of the circle to white
    circle.setPosition(position[0] - radius, position[1] - radius); // Set the position of the circle to the position of the particle
    window.draw(circle);                                            // Draw the circle on the window
}