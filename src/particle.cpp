#include "../include/elastic_collisions.hpp"

/*
    Constructor to initialize the particle's position, velocity, mass, and radius
*/
Particle::Particle(double x, double y) : position{x, y} {
    velocity = random2D(); // Get a random 2D vector by calling the random2D() function
    double speed = random(2.0, 6.0); // Get a random speed by calling the random() function
    velocity[0] *= speed; // Multiply the x component of the velocity by the speed for particle's movement
    velocity[1] *= speed; // Multiply the y component of the velocity by the speed for particle's movement
    mass = random(2.0, 6.0); // Get a random mass by calling the random() function
    radius = std::sqrt(mass) * 20; // Get the radius of the particles as related rationally to their mass for obtaining consistent sizes for each particle
}

/*
    Obtain a random double value between min and max
*/
double Particle::random(double min, double max) {
    static std::random_device rd; // Get a seed value for the random number generator
    static std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<double> distribution(min, max);  // Get a very precise random value by using a uniform distribution
    
    return distribution(gen); // Return the randomized value generated by the distribution
}

/*
    Obtain a random 2D vector
*/
std::array<double, 2> Particle::random2D() {
    std::array<double, 2> random2D;
    double angle = Particle::random(0.0, 2 * M_PI); // Get random angle between 0 to full circle as radians
    random2D[0] = std::cos(angle); // Get x component of the vector
    random2D[1] = std::sin(angle); // Get y component of the vector

    return random2D; // Return the 2D vector
}

/*
    Apply a force to the particle
*/
void Particle::applyForce(const std::array<double, 2>& force) {
    std::array<double, 2> f = force;
    f[0] /= mass; // Divide the x component of the force by the mass of the particle for getting the acceleration
    f[1] /= mass; // Divide the y component of the force by the mass of the particle for getting the acceleration
    acceleration[0] += f[0]; // Add the x component of the force to the x component of the acceleration
    acceleration[1] += f[1]; // Add the y component of the force to the y component of the acceleration
}

/*
    Update the particle's position and velocity based on current acceleration
    Formulas:
    x = x0 + v * dt and where x is the final position, x0 is the initial position, v is the velocity, and dt is the time
    v = u + at and where u is the initial velocity, v is the final velocity, a is the acceleration, t is the time
    For simplification, we can assume dt = 1
*/
void Particle::update() {
    /*
    Usage of the v = u + at:
    */
    velocity[0] += acceleration[0]; // Add the x component of the acceleration to the x component of the velocity
    velocity[1] += acceleration[1]; // Add the y component of the acceleration to the y component of the velocity

    /*
    Usage of the x = x0 + v:
    */
    position[0] += velocity[0]; // Add the x component of the velocity to the x component of the position
    position[1] += velocity[1]; // Add the y component of the velocity to the y component of the position

    /*
    Reset the acceleration to zero after updating the position and velocity
    */
    acceleration.fill(0.0); // Reset both components of the acceleration to zero
}

void Particle::collide(Particle& other) {
    std::array<double, 2> impactVector = {other.position[0] - position[0], other.position[1] - position[1]}; // Get the distance vector between the two particles
    double distance = std::hypot(impactVector[0], impactVector[1]); // Get the distance between the two particles using the hypot() function (vector magnitude)

    if (distance < radius + other.radius) { // Check if the distance between the two particles is less than the sum of their radius for preventing overlap between these particles
        double overlap = distance - (radius + other.radius); // Get the overlap distance between the two particles
        std::array<double, 2> direction = impactVector; // Get the direction of the impact vector
        double magnitude = std::hypot(direction[0], direction[1]); // Get the magnitude of the impact vector
        direction[0] /= magnitude; // Normalize the x component of the impact vector
        direction[1] /= magnitude; // Normalize the y component of the impact vector
        direction[0] *= overlap * 0.5; // Scale the x component of the direction by half of the overlap distance
        direction[1] *= overlap * 0.5; // Scale the y component of the direction by half of the overlap distance

        position[0] += direction[0]; // Move the particle in the x direction by the overlap distance
        position[1] += direction[1]; // Move the particle in the y direction by the overlap distance

        other.position[0] -= direction[0]; // Move the other particle in the x direction by the overlap distance
        other.position[1] -= direction[1]; // Move the other particle in the y direction by the overlap distance

        distance = radius + other.radius; // Update the distance between the two particles for

        impactVector[0] *= (distance / magnitude);
        impactVector[1] *= (distance / magnitude);

        double massSum = mass + other.mass; // Get the sum of the masses of the two particles for applying the formula of new velocities after collision

        /*
        Formula for new velocities after collision:
        v1' = v1 + (2 * m2 / (m1 + m2)) * (((v2 - v1) * (x2 - x1)) / |x2 - x1|^2)) * (x2 - x1)
        v2' = v2 + (2 * m1 / (m1 + m2)) * (((v1 - v2) * (x1 - x2)) / |x1 - x2|^2)) * (x1 - x2)
        where v1 and v2 are the initial velocities of the two particles, v1' and v2' are the final velocities of the two particles, m1 and m2 are the masses of the two particles, and x1 and x2 are the positions of the two particles
        */

        std::array<double, 2> vDiff = {other.velocity[0] - velocity[0], other.velocity[1] - velocity[1]}; // Get the difference between the velocities of the two particles by vector subtraction
        double numerator = vDiff[0] * impactVector[0] + vDiff[1] * impactVector[1]; // Get the numerator of the formula
        double denominator = massSum * distance * distance; // Get the denominator of the formula

        /*
        Get the change in velocities for the two particles after collision
        */
        std::array<double, 2> deltaVA = {impactVector[0] * (2 * other.mass * numerator / denominator),
                                        impactVector[1] * (2 * other.mass * numerator / denominator)};

                                        velocity[0] += deltaVA[0]; // Update the x component of the velocity of the current particle
                                        velocity[1] += deltaVA[1]; // Update the y component of the velocity of the current particle

        std::array<double, 2> deltaVB = {-impactVector[0] * (2 * mass * numerator / denominator),
                                        -impactVector[1] * (2 * mass * numerator / denominator)};

                                        other.velocity[0] += deltaVB[0]; // Update the x component of the velocity of the other particle
                                        other.velocity[1] += deltaVB[1]; // Update the y component of the velocity of the other particle
    }
}

/*
Check if the particle is at the edges of the window and bounce it off the edges
*/
void Particle::edges(double width, double height) {
    if (position[0] > width - radius) { // Check if the particle is at the right edge of the window
        position[0] = width - radius; // Set the x component of the position to the right edge of the window
        velocity[0] *= -1; // Reverse the x component of the velocity for bouncing off the right edge of the window
    } else if (position[0] < radius) { // Check if the particle is at the left edge of the window
        position[0] = radius; // Set the x component of the position to the left edge of the window
        velocity[0] *= -1; // Reverse the x component of the velocity for bouncing off the left edge of the window
    }

    if (position[1] > height - radius) { // Check if the particle is at the top edge of the window
        position[1] = height - radius; // Set the y component of the position to the top edge of the window
        velocity[1] *= -1; // Reverse the y component of the velocity for bouncing off the top edge of the window
    } else if (position[1] < radius) { // Check if the particle is at the bottom edge of the window
        position[1] = radius; // Set the y component of the position to the bottom edge of the window
        velocity[1] *= -1; // Reverse the y component of the velocity for bouncing off the bottom edge of the window
    }
}

/*
    Draw the particle on the window
*/
void Particle::draw(sf::RenderWindow& window) {
    sf::CircleShape circle(radius); // Create a circle shape with the radius of the particle
    circle.setFillColor(sf::Color::White); // Set the fill color of the circle to white
    circle.setPosition(position[0] - radius, position[1] - radius); // Set the position of the circle to the position of the particle
    window.draw(circle); // Draw the circle on the window
}